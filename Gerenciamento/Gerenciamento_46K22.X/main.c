/*******************************************************************************************************
 * File:   main.c
 * Author: Hiroki
 *
 * Created on 5 de Maio de 2016, 18:08
 * SW GERENCIAMENTO VERSÃO 1.0
 * Autor: Gustavo Hiroki
 * Modificação: Início declarações e SPI
 * 05/05/2016
 ******************************************************************************************************/
/*******************************************************************************************************
 * File:   main.c
 * Author: Hiroki
 *
 * Created on 27 de Junho de 2016, 23:40
 * SW GERENCIAMENTO VERSÃO 1.0
 * Autor: Gustavo Hiroki
 * Modificação: Implementação de Timer´s 0/1/2/3/4/5/6
 * 27/06/2016
 ******************************************************************************************************/
/*******************************************************************************************************
 * File:   main.c
 * Author: Hiroki
 *
 * Created on 4 de Julho de 2016, 16:47
 * SW GERENCIAMENTO VERSÃO 1.0
 * Autor: Gustavo Hiroki
 * Modificação: Implementação e Teste de Interrupção Externa
 * 04/07/2016
 ******************************************************************************************************/
/*******************************************************************************************************
 * File:   main.c
 * Author: Hiroki
 *
 * Created on 5 de Julho de 2016, 16:33
 * SW GERENCIAMENTO VERSÃO 1.0
 * Autor: Gustavo Hiroki
 * Modificação: Configuração do HW e Finalização
 * 05/07/2016
 ******************************************************************************************************/
/*******************************************************************************************************
 * File:   main.c
 * Author: Hiroki
 *
 * Created on 9 de Julho de 2016, 13:28
 * SW GERENCIAMENTO VERSÃO 1.0
 * Autor: Gustavo Hiroki
 * Modificação: Efetuado testes em HW(Demerson)
 * 09/07/2016
 ******************************************************************************************************/
/*******************************************************************************************************
 * File:   main.c
 * Author: Hiroki
 *
 * Created on 17 de Setembro de 2016, 13:28
 * SW GERENCIAMENTO VERSÃO 1.0
 * Autor: Gustavo Hiroki
 * Modificação: Modificação placa MARK1
 * 17/09/2016
 ******************************************************************************************************/
/*******************************************************************************************************
 * File:   main.c
 * Author: Hiroki
 *
 * Created on 01 de Setembro de 2017, 15:15
 * SW GERENCIAMENTO VERSÃO 1.1
 * Autor: Antonio Ferreira
 * Modificação: Modificação placa MARK2 troca de pinos, Configuração do CCP1
 * 01/09/2017
 ******************************************************************************************************/
/*******************************************************************************************************
 * File:   main.c
 * Author: Hiroki
 *
 * Created on 21 de Setembro de 2017, 20:41
 * SW GERENCIAMENTO VERSÃO 1.1
 * Autor: Antonio Ferreira
 * Modificação: Implementação dos algoritimos do sensor de Etanol
 * 21/09/2017
 ******************************************************************************************************/
/*******************************************************************************************************
 * File:   main.c
 * Author: Hiroki
 *
 * Created on 21 de Setembro de 2017, 20:41
 * SW GERENCIAMENTO VERSÃO 1.1
 * Autor: Antonio Ferreira
 * Modificação: Implementação dos algoritimos Avanço de ignição
 * 23/10/2017
 ******************************************************************************************************/

/**************************************** INCLUDE LIBRARY ********************************************/
#include <xc.h>
#include <math.h>
#include <pic18f46k22.h>
#include "Config_XC8.h"
#include "SPI_XC8.h"
#include "TIMERS_XC8.h"
#include "EXT_INT.h"
#include "ADC_K22.h"

#define     GOL     1
#define     POLO    0
#define     CarCfg  POLO

/******************************************* DEFINES ************************************************/
#define     nSINAL_ENT       LATBbits.LATB0     //Rotação Input
#define     nROT_CCP2        LATBbits.LATB3
#define     nSINAL_SS_SINC   LATCbits.LATC6     //RC6 Dig Output
#define     nSINAL_SS_ADM    LATEbits.LATE1     //RE1 Dig Output
#define     nSINAL_SS_COM    LATBbits.LATB2     
#define     nSINAL_SS_33810  LATCbits.LATC1
#define     nCOMBUSTIVEL_PIN LATCbits.LATC2     
#define     nSINAL_FALHA     LATBbits.LATB7
#define     nL15             LATBbits.LATB1
#define     nBOMBA_CB        LATDbits.LATD1
#define     PORTB5_nL15      PORTBbits.RB1
#define     nLED_TEST        LATCbits.LATC0     //RC0 Dig Output 
#define     nSINAL_SS_33972  LATDbits.LATD3     //ChipSelect KNOCK
#define     nEMBREAGEM_PIN   LATCbits.LATC7
#define     nBUTTON_AC       PORTDbits.RD6
#define     nRELE_BOMB_INJ   LATDbits.LATD7
#define     nHOLD_KNOCK      LATBbits.LATB6
#define     nFREIO_1         LATDbits.LATD2
#define     nFREIO_2         LATDbits.LATD5
#define     nDO_KNOCK        LATEbits.LATE2

#define     nSINAL_SS_COM    LATBbits.LATB6     //RB6 Dig Output

/*********************************** Calibrações - Polo *********************************************/
#define     nPEDAL_MAXPOLO      185.6      // Pedal pressionado
#define     nPEDAL_MINPOLO      46.0       // Pedal solto

#define     nPEDAL_MAXGOL       196.0      // 191.0
#define     nPEDAL_MINGOL       38.0       // 42.0

#define     REF_TORQUE_MLenta      40
#define     rotacao_mlenta_control 1100

#define     nTPS_MAXPOLO        241.0      // Borboleta Aberta
#define     nTPS_MIN2POLO       23.0       // Borboleta Completamente fechada

#define     nTPS_MAXGOL         236.0
#define     nTPS_MIN2GOL        27.54

#define     nTPS_MIN            40.0       // Borboleta Fechada (Relaxada)

#define     nTPS_1000           35.0       // Borboleta na posicao de regime
#define     nTPS_6000           65.0       // Borboleta na posicao para rotacao = 6000 rpm

#define     nMAX_TIME_INJPOLO   10000.0
#define     nMIN_TIME_INJPOLO   2800.0//3000//2700.0

#define     nMAX_TIME_INJGOL    15000.0    //us
#define     nMIN_TIME_INJGOL    2700.0     //us
#define     nMIN_TIME_INJPART   2000.0     //us
#define     nMAX_TIME_INJPART   8700.0     //us

#define     Bob_TimingPOLO      5800.0
#define     Vazao_InjPOLO       339.11717  /*POLO  1/(176.93/60) */

#define     Vazao_InjGOL        400.0      /*GOL vazão de 2,5 g/seg*/
#define     Bob_TimingGOL       4000.0

#define     Const_Gases         1379.379    //1727.707

#define     nEstequio_Gasolina   133        // Estequiometria Gasolina = (133/10) = 13,3
#define     nEstequio_Etanol     90         // Estequiometria Etanol = (90/10) = 9,0
#define     nEstequio_Media      1150       // Estequiometria Média = (1150/100) = 11,50

#define     MIN_REFVB           35.0
/*****************************************************************************************************/
#define     nPin_HIGH            1
#define     nPin_LOW             0
#define     nYes                 1
#define     nNo                  0
#define     nON                  1
#define     nOFF                 0
#define     nDigital_Pin         0
#define     nAnalog_Pin          1

#define     fator_injPartida    20

/********************************** Variaveis globais *************************************************/
short int       a, b, c, d, e;                   /* Variaveis de status do programa */
unsigned char   dente;                        /* Incrementado a cada dente */
int             rotacao_mlenta;
int             rotacao;                      /* Rotacao do motor dividida por 100. 0 a 60 - 0 RPM a 6000 RPM */
long int        t_periodo, t_periodo_ref;     /* Armazena os tempos de patamar em alto */
unsigned char   address;                      /* Guarda o deslocamento para a leitura na memoria de programa */
unsigned char   address_2;
int             periodo;                      // Periodo do dente (em contagem)
int             n_extra;
unsigned int   Estequiometria = 1330;  //Estequiometria = (1330 / 100) = 13,3
unsigned int   Old_Estequiometria = 0; //Armazena Valores de estequiometria

int ig_pos; // Variavel de controle da ignicao.
            // 0-sem ignicao
            // 1-sinal de ignicao ativo(2ms)
            // 23-inicio da ignicao do "meio" (cil. 2 e 3)
            // 14-inicio da ignicao do "fim" (cil. 1 e 4)

/*_____short calculo_ok;____ */
short           falha_ok;
short           volta_spi;

/*_________________________________ Variaveis para injecao e ignicao ____________________________________*/
int    ig_dente_14;                    /* Armazena o dente de referencia para a ignicao 14 */
int    ig_tmr_disparo;                 /* Armazena o tempo de disparo do timer0 a partir
                                                   do dente de referencia (igual para as duas ignicoes) */
int    ij_dente_14;                    /* Armazena o dente de referencia para a injecoes 1 e 4 */
int    ij_tmr_disparo;                 /* Armazena o tempo de disparo do timer3 a partir
                                                   do dente de referencia (igual para as injecoes 1 e 4) */
int    tempo_bob;                      /* tempo de carregamento da bobina de ign */
int    tempo_inj;                      /* tempo de injecao */
float         t_inj_real;
float         t_inj_lim;
int           t_inj_extra;
int           ij_dente_14_temp;
int           ij_dente_14_extra; //static

/*___________________________________________ Sensores ___________________________________________________*/
int            lambda = 1;//para leitura do sensor Lambda (HEGO)
int            map;   //para leitura do sensor map
float          pressao_ar;
long           VarTest = 0;
int            sensor_t_agua; //static
float          rs;
int            t_agua; // temperatura da agua
float          t_ar; // temperatura do ar
int            t_ar_com;
float          m_ar; //Rotina ECU Freescale
float          m_comb; //Rotina ECU Freescale
int            pedal_ad;
unsigned char  VoltBattery;
float          fator_corr_vbat ;
float          Battery;
float          fator_inj;
float          fator_inj_Aceleracao;  //Correção do tempo de inj. 

unsigned int   sensor_t_ar;
unsigned int   sensor_Comb_Flex;
unsigned char Percentual_Etanol = 0;       // Percentual de etanol no combustível
unsigned char Percentual_Gasolina = 0;     // Percentual de gasolina no combustível
unsigned char Old_Percentual_Etanol = 0;       // Percentual de etanol no combustível
unsigned char Old_Percentual_Gasolina = 0;     // Percentual de gasolina no combustível

/*_______________________________________ Variables TIMER 3 _______________________________________________*/
float   ig_tmr_disparo_temp, ij_tmr_disparo_temp, tempo_inj_temp /*tempo_bob_temp*/; //Original era float
//long int    tempo_inj_temp;
unsigned int tempo_bob_temp;
float        tempo_inj_temp_1;
int          ig_dente_14_temp;                                         // dente de referencia para a subida do sinal
int          ij_dente_14_temp;                                         // dente de referencia para a subida do sinal
float        rotacao_temp;
float        periodo_52;
float        ij_14_temp;
float        ig_14_temp;
float        ig_14_temp_Gasolina;
float        ig_14_temp_Etanol;
int     n;                                                                          // Dentes para adiantar em relacao ao tabelado
int     n_e;
float   ij_14_extra;
float   rotacao_temp_1;
int    tempo_Inj_com;
/*******************************************************************************************/
//Controle de RPM                                                                          //
//const float Kref1 = (TPS_6000-TPS_1000) /(PEDAL_MAX-PEDAL_MIN);                          //
//const float Kref2 = -(PEDAL_MIN*(TPS_6000-TPS_1000) /(PEDAL_MAX-PEDAL_MIN)) + TPS_1000;  //
/*******************************************************************************************/

/*_________________________________ Variaveis utilizadas no algoritmo PI - Injecao _________________________*/
const float     Kp_inj = 0.00017;           // 0.00012;

/*_______________________ Variaveis utilizados no algoritmo PI - Controle de Rotacao _______________________*/
float           ref_rpm;            // Sinal de referencia (pedal convertido p/ escala de RPM)
float           erro_rpm;
float           soma_erro_rpm;
float           Kp_rpm;             // Anterior: constante = 2.0
const float     Ki_rpm = 0.00004;   // Anterior: 0.00012     //HIROKI = 0.00002
unsigned char   injecao_ok;         //Testar comando
int             ref_vb;             // Sinal de referencia (pedal convertido p/ escala da vb
float           Kref1_rpm;
float           Kref2_rpm;
float           ref_vb_max;
float           ref_vb_base;
long int        temp;
short int       dm;

int ATUALref_vb = 35;
int ANTref_vb = 35;

unsigned int AD_Req = 0;
short        Send_Spi = 0;
unsigned char Send_Spi_2 = 255;
unsigned char Rele_bomb_Count = 255;
unsigned char   OffSet_refRPM = 0;
short Flag_MarchaLenta = 0;

typedef enum
{
	enReleInit = 0,
	enRele_1 = enReleInit,
	enRele_2,
	enRele_3,
	enRele_4,
	enRele_5,
	enRele_6,
	enRele_7,
	enRele_8,
	enReleMax
}EnumReles;

static union
{
	unsigned int u8All;
	struct
	{
		unsigned Rele1:1;
		unsigned Rele2:1;
		unsigned Rele3:1;
		unsigned Rele4:1;
		unsigned Rele5:1;
		unsigned Rele6:1;
		unsigned Rele7:1;
		unsigned Rele8:1;
	}StatusAllReles;
}UnionAllReles;

/*ex: SetBit(UnionAllReles.u8aAll, enRele_1)*/
#define SetBit(value,Bit)		((value) |= (1 << (Bit)))

/*ex: GetBit(UnionAllReles.u8aAll, enRele_1)*/	
#define GetBit(value,Bit)		((value) >> (Bit) & 0x01)

/*ex: ClearBit(UnionAllReles.u8aAll, enRele_1)*/
void ClearBit(unsigned char *value, unsigned char Bit)
{
	unsigned char aux = (1 << (Bit));					
	*value = *value & (unsigned char)(~aux);
}

void lambda_ad_Read();
void map_ad_Read();
void t_ar_ad_Read();
void t_agua_ad_Read();
void pedal_ad_Read();
void Battery_ad_Read();
inline void controle_rpm();
void Spi_Write16(unsigned int data);
void Spi2_Write16(unsigned int data);
inline void conta_dente();
void Comb_CCP_Read();
float controle_Avn_marchaLenta();

/*______________________________________ MAP DENTE_IG14 _________________________________________________________________*/
//const float ig_refPOLO[66][10] = {
//{ 200.00 , 200.00 , 200.00 , 200.00 , 200.00 , 200.00 , 200.00 , 200.00 , 200.00 , 200.00 },    /*000 rpm*/
//{ 14.50 , 14.50 , 14.50 , 14.50 , 14.50 , 14.50 , 14.50 , 14.50 , 14.50 , 14.50 },              /*100 rpm*/
//{ 14.50 , 14.50 , 14.50 , 14.50 , 14.50 , 14.50 , 14.50 , 14.50 , 14.50 , 14.50 },              /*200 rpm*/
//{ 14.50 , 14.50 , 14.50 , 14.50 , 14.50 , 14.50 , 14.50 , 14.50 , 14.50 , 14.50 },              /*300 rpm*/
//{ 14.10 , 14.10 , 14.10 , 14.10 , 14.10 , 14.10 , 14.10 , 14.10 , 14.10 , 14.10 },              /*400 rpm*/
//{ 13.10 , 13.10 , 13.10 , 13.10 , 13.10 , 13.10 , 13.10 , 13.10 , 13.10 , 13.10 },              /*500 rpm*/
//{ 13.10 , 13.10 , 13.10 , 13.10 , 13.10 , 13.10 , 13.10 , 13.10 , 13.10 , 13.10 },              /*600 rpm*/
//{ 12.50 , 12.50 , 12.33 , 12.33 , 12.33 , 12.33 , 12.33 , 12.33 , 12.33 , 12.33 },              /*700 rpm*/
//{ 12.53 , 12.54 , 12.21 , 12.21 , 12.23 , 12.23 , 12.23 , 12.23 , 12.34 , 12.38 },              /*800 rpm*/
//{ 12.54 , 12.55 , 12.11 , 12.11 , 12.14 , 12.14 , 12.14 , 12.14 , 12.34 , 12.41 },              /*900 rpm*/
//{ 12.52 , 12.53 , 12.02 , 12.03 , 12.05 , 12.05 , 12.05 , 12.05 , 12.31 , 12.42 },              /*1000 rpm*/
//{ 12.47 , 12.48 , 11.95 , 11.95 , 11.97 , 11.97 , 11.97 , 11.97 , 12.28 , 12.40 },              /*1100 rpm*/
//{ 12.41 , 12.41 , 11.88 , 11.89 , 11.90 , 11.90 , 11.90 , 11.90 , 12.23 , 12.37 },              /*1200 rpm*/
//{ 12.33 , 12.33 , 11.83 , 11.83 , 11.83 , 11.83 , 11.83 , 11.83 , 12.17 , 12.33 },              /*1300 rpm*/
//{ 12.23 , 12.23 , 11.78 , 11.78 , 11.77 , 11.77 , 11.77 , 11.77 , 12.10 , 12.27 },              /*1400 rpm*/
//{ 12.13 , 12.12 , 11.74 , 11.73 , 11.71 , 11.71 , 11.71 , 11.71 , 12.03 , 12.21 },              /*1500 rpm*/
//{ 12.01 , 12.00 , 11.69 , 11.69 , 11.66 , 11.66 , 11.66 , 11.66 , 11.96 , 12.14 },              /*1600 rpm*/
//{ 11.88 , 11.88 , 11.65 , 11.65 , 11.61 , 11.61 , 11.61 , 11.61 , 11.88 , 12.06 },              /*1700 rpm*/
//{ 11.76 , 11.75 , 11.61 , 11.60 , 11.57 , 11.57 , 11.57 , 11.57 , 11.81 , 11.98 },              /*1800 rpm*/
//{ 11.63 , 11.62 , 11.56 , 11.55 , 11.53 , 11.53 , 11.53 , 11.53 , 11.74 , 11.91 },              /*1900 rpm*/
//{ 11.50 , 11.50 , 11.50 , 11.50 , 11.50 , 11.50 , 11.50 , 11.50 , 11.67 , 11.83 },              /*2000 rpm*/
//{ 11.38 , 11.38 , 11.44 , 11.44 , 11.47 , 11.47 , 11.47 , 11.47 , 11.61 , 11.76 },              /*2100 rpm*/
//{ 11.26 , 11.28 , 11.36 , 11.38 , 11.45 , 11.45 , 11.45 , 11.45 , 11.56 , 11.69 },              /*2200 rpm*/
//{ 11.14 , 11.17 , 11.28 , 11.31 , 11.43 , 11.43 , 11.43 , 11.43 , 11.52 , 11.63 },              /*2300 rpm*/
//{ 11.02 , 11.07 , 11.20 , 11.24 , 11.41 , 11.41 , 11.41 , 11.41 , 11.48 , 11.57 },              /*2400 rpm*/
//{ 10.91 , 10.98 , 11.11 , 11.16 , 11.39 , 11.39 , 11.39 , 11.39 , 11.44 , 11.52 },              /*2500 rpm*/
//{ 10.79 , 10.88 , 11.02 , 11.09 , 11.37 , 11.37 , 11.37 , 11.37 , 11.41 , 11.47 },              /*2600 rpm*/
//{ 10.68 , 10.79 , 10.93 , 11.02 , 11.36 , 11.36 , 11.36 , 11.36 , 11.38 , 11.42 },              /*2700 rpm*/
//{ 10.56 , 10.69 , 10.84 , 10.95 , 11.34 , 11.34 , 11.34 , 11.34 , 11.35 , 11.38 },              /*2800 rpm*/
//{ 10.45 , 10.60 , 10.76 , 10.89 , 11.32 , 11.32 , 11.32 , 11.32 , 11.33 , 11.34 },              /*2900 rpm*/
//{ 10.33 , 10.50 , 10.67 , 10.83 , 11.30 , 11.30 , 11.30 , 11.30 , 11.30 , 11.30 },              /*3000 rpm*/
//{ 10.21 , 10.40 , 10.59 , 10.78 , 11.28 , 11.28 , 11.28 , 11.28 , 11.27 , 11.26 },              /*3100 rpm*/
//{ 10.09 , 10.30 , 10.51 , 10.73 , 11.25 , 11.25 , 11.25 , 11.25 , 11.24 , 11.23 },              /*3200 rpm*/
//{  9.96 , 10.19 , 10.44 , 10.70 , 11.22 , 11.22 , 11.22 , 11.22 , 11.21 , 11.19 },              /*3300 rpm*/
//{  9.84 , 10.09 , 10.37 , 10.66 , 11.19 , 11.19 , 11.19 , 11.19 , 11.18 , 11.16 },              /*3400 rpm*/
//{  9.72 ,  9.98 , 10.30 , 10.63 , 11.16 , 11.16 , 11.16 , 11.16 , 11.15 , 11.13 },              /*3500 rpm*/
//{  9.60 ,  9.88 , 10.23 , 10.60 , 11.13 , 11.13 , 11.13 , 11.13 , 11.12 , 11.10 },              /*3600 rpm*/
//{  9.48 ,  9.78 , 10.17 , 10.58 , 11.10 , 11.10 , 11.10 , 11.10 , 11.09 , 11.08 },              /*3700 rpm*/
//{  9.37 ,  9.68 , 10.11 , 10.55 , 11.06 , 11.06 , 11.06 , 11.06 , 11.06 , 11.05 },              /*3800 rpm*/
//{  9.27 ,  9.59 , 10.06 , 10.53 , 11.03 , 11.03 , 11.03 , 11.03 , 11.03 , 11.02 },              /*3900 rpm*/
//{  9.17 ,  9.50 , 10.00 , 10.50 , 11.00 , 11.00 , 11.00 , 11.00 , 11.00 , 11.00 },              /*4000 rpm*/
//{  9.08 ,  9.42 ,  9.95 , 10.47 , 10.97 , 10.97 , 10.97 , 10.97 , 10.97 , 10.98 },              /*4100 rpm*/
//{  9.00 ,  9.35 ,  9.89 , 10.44 , 10.94 , 10.94 , 10.94 , 10.94 , 10.94 , 10.95 },              /*4200 rpm*/
//{  8.93 ,  9.28 ,  9.84 , 10.41 , 10.91 , 10.91 , 10.91 , 10.91 , 10.92 , 10.93 },              /*4300 rpm*/
//{  8.87 ,  9.23 ,  9.79 , 10.37 , 10.89 , 10.89 , 10.89 , 10.89 , 10.90 , 10.91 },              /*4400 rpm*/
//{  8.83 ,  9.19 ,  9.74 , 10.33 , 10.86 , 10.86 , 10.86 , 10.86 , 10.87 , 10.89 },              /*4500 rpm*/
//{  8.80 ,  9.16 ,  9.70 , 10.28 , 10.84 , 10.84 , 10.84 , 10.84 , 10.85 , 10.87 },              /*4600 rpm*/
//{  8.78 ,  9.14 ,  9.65 , 10.22 , 10.83 , 10.83 , 10.83 , 10.83 , 10.84 , 10.85 },              /*4700 rpm*/
//{  8.78 ,  9.13 ,  9.60 , 10.16 , 10.81 , 10.81 , 10.81 , 10.81 , 10.82 , 10.84 },              /*4800 rpm*/
//{  8.80 ,  9.14 ,  9.55 , 10.08 , 10.80 , 10.80 , 10.80 , 10.80 , 10.81 , 10.82 },              /*4900 rpm*/
//{  8.83 ,  9.17 ,  9.50 , 10.00 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 },              /*5000 rpm*/
//{  8.83 ,  9.17 ,  9.50 , 10.00 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 },              /*5100 rpm*/
//{  8.83 ,  9.17 ,  9.50 , 10.00 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 },              /*5200 rpm*/
//{  8.83 ,  9.17 ,  9.50 , 10.00 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 },              /*5400 rpm*/
//{  8.83 ,  9.17 ,  9.50 , 10.00 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 },              /*5500 rpm*/
//{  8.83 ,  9.17 ,  9.50 , 10.00 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 },              /*5600 rpm*/
//{  8.83 ,  9.17 ,  9.50 , 10.00 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 },              /*5700 rpm*/
//{  8.83 ,  9.17 ,  9.50 , 10.00 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 },              /*5800 rpm*/
//{  8.83 ,  9.17 ,  9.50 , 10.00 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 },              /*5900 rpm*/
//{  8.83 ,  9.17 ,  9.50 , 10.00 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 },              /*6000 rpm*/
//{  8.83 ,  9.17 ,  9.50 , 10.00 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 },              /*6100 rpm*/
//{  8.83 ,  9.17 ,  9.50 , 10.00 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 },              /*6200 rpm*/
//{  8.83 ,  9.17 ,  9.50 , 10.00 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 },              /*6300 rpm*/
//{  8.83 ,  9.17 ,  9.50 , 10.00 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 },              /*6400 rpm*/
//{  8.83 ,  9.17 ,  9.50 , 10.00 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 },              /*6500 rpm*/
//{  8.83 ,  9.17 ,  9.50 , 10.00 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 , 10.80 }};             /*6600 rpm*/


/************************************************** AVANÇO DE IGNIÇÃO PARA A GASOLINA ******************************************************/
const float ig_refGOL_Gasolina[66][10] = {
{	200.00	,	200.00	,	200.00	,	200.00	,	200.00	,	200.00	,	200.00	,	200.00	,	200.00	,	200.00	},      /*000 rpm*/
{	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	},      /*100 rpm*/
{	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	},      /*200 rpm*/
{	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	},      /*300 rpm*/
{	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	,	14.00	},      /*400 rpm*/
{	13.70	,	13.70	,	13.70	,	13.68	,	13.68	,	13.68	,	13.68	,	13.68	,	13.68	,	13.68	},      /*500 rpm*/
{	13.64	,	13.64	,	13.64	,	13.60	,	13.60	,	13.59	,	13.59	,	13.60	,	13.59	,	13.59	},      /*600 rpm*/
{	13.58	,	13.58	,	13.58	,	13.53	,	13.53	,	13.53	,	13.53	,	13.53	,	13.53	,	13.53	},      /*700 rpm*/
{	13.55	,	13.55	,	13.55	,	13.50	,	13.50	,	13.50	,	13.50	,	13.50	,	13.50	,	13.50	},      /*800 rpm*/
{	13.59	,	13.59	,	13.58	,	13.53	,	13.53	,	13.52	,	13.52	,	13.53	,	13.53	,	13.53	},      /*900 rpm*/
{	13.55	,	13.55	,	13.55	,	13.50	,	13.50	,	13.50	,	13.50	,	13.50	,	13.50	,	13.50	},      /*1000 rpm*/
{	13.31	,	13.30	,	13.34	,	13.29	,	13.29	,	13.33	,	13.33	,	13.30	,	13.33	,	13.33	},      /*1100 rpm*/
{	12.89	,	12.88	,	12.99	,	12.94	,	12.94	,	13.04	,	13.04	,	12.98	,	13.03	,	13.03	},      /*1200 rpm*/
{	12.38	,	12.37	,	12.54	,	12.50	,	12.50	,	12.67	,	12.67	,	12.58	,	12.67	,	12.67	},      /*1300 rpm*/
{	11.85	,	11.84	,	12.06	,	12.04	,	12.04	,	12.27	,	12.27	,	12.19	,	12.31	,	12.31	},      /*1400 rpm*/
{	11.38	,	11.38	,	11.63	,	11.63	,	11.63	,	11.88	,	11.88	,	11.88	,	12.00	,	12.00	},      /*1500 rpm*/
{	11.01	,	11.04	,	11.27	,	11.30	,	11.30	,	11.53	,	11.53	,	11.68	,	11.79	,	11.79	},      /*1600 rpm*/
{	10.77	,	10.83	,	11.00	,	11.06	,	11.06	,	11.25	,	11.25	,	11.59	,	11.66	,	11.66	},      /*1700 rpm*/
{	10.61	,	10.71	,	10.82	,	10.89	,	10.90	,	11.03	,	11.02	,	11.55	,	11.59	,	11.59	},      /*1800 rpm*/
{	10.53	,	10.66	,	10.71	,	10.80	,	10.80	,	10.86	,	10.86	,	11.54	,	11.55	,	11.55	},      /*1900 rpm*/
{	10.50	,	10.67	,	10.67	,	10.75	,	10.75	,	10.75	,	10.75	,	11.50	,	11.50	,	11.50	},      /*2000 rpm*/
{	10.51	,	10.69	,	10.68	,	10.74	,	10.74	,	10.70	,	10.70	,	11.41	,	11.43	,	11.43	},      /*2100 rpm*/
{	10.53	,	10.73	,	10.73	,	10.75	,	10.76	,	10.69	,	10.71	,	11.29	,	11.34	,	11.35	},      /*2200 rpm*/
{	10.55	,	10.75	,	10.78	,	10.77	,	10.78	,	10.72	,	10.74	,	11.15	,	11.25	,	11.26	},      /*2300 rpm*/
{	10.54	,	10.73	,	10.79	,	10.77	,	10.81	,	10.77	,	10.80	,	11.04	,	11.18	,	11.18	},      /*2400 rpm*/
{	10.50	,	10.67	,	10.75	,	10.75	,	10.83	,	10.83	,	10.88	,	10.96	,	11.13	,	11.13	},      /*2500 rpm*/
{	10.40	,	10.54	,	10.63	,	10.68	,	10.83	,	10.90	,	10.94	,	10.94	,	11.11	,	11.10	},      /*2600 rpm*/
{	10.27	,	10.37	,	10.45	,	10.59	,	10.80	,	10.96	,	11.00	,	10.96	,	11.12	,	11.11	},      /*2700 rpm*/
{	10.12	,	10.18	,	10.24	,	10.47	,	10.75	,	11.00	,	11.04	,	11.01	,	11.14	,	11.12	},      /*2800 rpm*/
{	9.98	,	10.01	,	10.04	,	10.34	,	10.66	,	11.00	,	11.04	,	11.04	,	11.14	,	11.13	},      /*2900 rpm*/
{	9.88	,	9.88	,	9.88	,	10.21	,	10.54	,	10.96	,	11.00	,	11.04	,	11.13	,	11.13	},      /*3000 rpm*/
{	9.81	,	9.80	,	9.77	,	10.09	,	10.39	,	10.86	,	10.92	,	10.99	,	11.07	,	11.09	},      /*3100 rpm*/
{	9.78	,	9.77	,	9.73	,	10.00	,	10.22	,	10.73	,	10.80	,	10.91	,	10.99	,	11.05	},      /*3200 rpm*/
{	9.78	,	9.76	,	9.72	,	9.92	,	10.06	,	10.58	,	10.67	,	10.80	,	10.90	,	10.99	},      /*3300 rpm*/
{	9.77	,	9.76	,	9.73	,	9.86	,	9.92	,	10.42	,	10.55	,	10.70	,	10.81	,	10.93	},      /*3400 rpm*/
{	9.75	,	9.75	,	9.75	,	9.83	,	9.83	,	10.29	,	10.46	,	10.63	,	10.75	,	10.88	},      /*3500 rpm*/
{	9.71	,	9.71	,	9.77	,	9.83	,	9.81	,	10.20	,	10.41	,	10.59	,	10.72	,	10.84	},      /*3600 rpm*/
{	9.65	,	9.66	,	9.78	,	9.86	,	9.84	,	10.14	,	10.40	,	10.59	,	10.73	,	10.82	},      /*3700 rpm*/
{	9.61	,	9.61	,	9.81	,	9.91	,	9.93	,	10.13	,	10.43	,	10.62	,	10.76	,	10.82	},      /*3800 rpm*/
{	9.59	,	9.59	,	9.87	,	10.00	,	10.05	,	10.17	,	10.49	,	10.68	,	10.81	,	10.84	},      /*3900 rpm*/
{	9.63	,	9.63	,	9.96	,	10.13	,	10.21	,	10.25	,	10.58	,	10.75	,	10.88	,	10.88	},      /*4000 rpm*/
{	9.72	,	9.72	,	10.09	,	10.28	,	10.39	,	10.38	,	10.69	,	10.84	,	10.94	,	10.92	},      /*4100 rpm*/
{	9.86	,	9.86	,	10.25	,	10.45	,	10.57	,	10.54	,	10.82	,	10.92	,	11.00	,	10.98	},      /*4200 rpm*/
{	10.03	,	10.03	,	10.42	,	10.61	,	10.75	,	10.71	,	10.94	,	11.01	,	11.05	,	11.04	},      /*4300 rpm*/
{	10.21	,	10.21	,	10.58	,	10.76	,	10.90	,	10.87	,	11.04	,	11.08	,	11.10	,	11.09	},      /*4400 rpm*/
{	10.38	,	10.38	,	10.71	,	10.88	,	11.00	,	11.00	,	11.13	,	11.13	,	11.13	,	11.13	},      /*4500 rpm*/
{	10.50	,	10.50	,	10.79	,	10.93	,	11.04	,	11.07	,	11.17	,	11.14	,	11.13	,	11.14	},      /*4600 rpm*/
{	10.58	,	10.58	,	10.80	,	10.92	,	11.00	,	11.07	,	11.17	,	11.12	,	11.12	,	11.13	},      /*4700 rpm*/
{	10.57	,	10.57	,	10.73	,	10.81	,	10.87	,	10.98	,	11.10	,	11.06	,	11.07	,	11.09	},      /*4800 rpm*/
{	10.47	,	10.47	,	10.55	,	10.59	,	10.63	,	10.77	,	10.97	,	10.93	,	10.99	,	11.01	},      /*4900 rpm*/
{	10.25	,	10.25	,	10.25	,	10.25	,	10.25	,	10.42	,	10.75	,	10.75	,	10.88	,	10.88	},      /*5000 rpm*/
{	10.25	,	10.25	,	10.25	,	10.25	,	10.25	,	10.42	,	10.75	,	10.75	,	10.88	,	10.88	},      /*5100 rpm*/
{	10.25	,	10.25	,	10.25	,	10.25	,	10.25	,	10.42	,	10.75	,	10.75	,	10.88	,	10.88	},      /*5200 rpm*/
{	10.25	,	10.25	,	10.25	,	10.25	,	10.25	,	10.42	,	10.75	,	10.75	,	10.88	,	10.88	},      /*5300 rpm*/
{	10.25	,	10.25	,	10.25	,	10.25	,	10.25	,	10.42	,	10.75	,	10.75	,	10.88	,	10.88	},      /*5400 rpm*/
{	10.25	,	10.25	,	10.25	,	10.25	,	10.25	,	10.42	,	10.75	,	10.75	,	10.88	,	10.88	},      /*5500 rpm*/
{	10.25	,	10.25	,	10.25	,	10.25	,	10.25	,	10.42	,	10.75	,	10.75	,	10.88	,	10.88	},      /*5600 rpm*/
{	10.25	,	10.25	,	10.25	,	10.25	,	10.25	,	10.42	,	10.75	,	10.75	,	10.88	,	10.88	},      /*5700 rpm*/
{	10.25	,	10.25	,	10.25	,	10.25	,	10.25	,	10.42	,	10.75	,	10.75	,	10.88	,	10.88	},      /*5800 rpm*/
{	10.25	,	10.25	,	10.25	,	10.25	,	10.25	,	10.42	,	10.75	,	10.75	,	10.88	,	10.88	},      /*5900 rpm*/
{	10.25	,	10.25	,	10.25	,	10.25	,	10.25	,	10.42	,	10.75	,	10.75	,	10.88	,	10.88	},      /*6000 rpm*/
{	10.25	,	10.25	,	10.25	,	10.25	,	10.25	,	10.42	,	10.75	,	10.75	,	10.88	,	10.88	},      /*6100 rpm*/
{	10.25	,	10.25	,	10.25	,	10.25	,	10.25	,	10.42	,	10.75	,	10.75	,	10.88	,	10.88	},      /*6200 rpm*/
{	10.25	,	10.25	,	10.25	,	10.25	,	10.25	,	10.42	,	10.75	,	10.75	,	10.88	,	10.88	},      /*6300 rpm*/
{	10.25	,	10.25	,	10.25	,	10.25	,	10.25	,	10.42	,	10.75	,	10.75	,	10.88	,	10.88	},      /*6400 rpm*/
{	10.25	,	10.25	,	10.25	,	10.25	,	10.25	,	10.42	,	10.75	,	10.75	,	10.88	,	10.88	}};     /*6500 rpm*/


/**************************************************** AVANÇO DE IGNIÇÃO PARA O ETANOL ******************************************************/
const float ig_refGOL_Etanol[66][10] = {
{	200.00  ,	200.00	,	200.00	,	200.00	,	200.00	,	200.00	,	200.00	,	200.00	,	200.00	,	200.00	},      /*000 rpm*/
{   11.50	,   11.50	,   11.16	,   11.16   ,	11.16   ,	11.16	,   11.50	,   11.50	,   11.50	,   11.50   },      /*100 rpm*/
{   11.50	,   11.50	,   11.16   ,	11.16	,   10.58   ,	10.58   ,	10.13   ,	11.50	,   11.50	,   11.50   },      /*200 rpm*/
{   11.50	,   11.50	,   11.16	,   11.16   ,	10.58   ,	10.58   ,	10.13   ,	11.50	,   11.50	,   11.50   },      /*300 rpm*/
{   11.50	,   11.50	,   11.16	,   11.16   ,	10.58   ,	10.58   ,	10.13   ,	11.50	,   11.50	,   11.50   },      /*400 rpm*/       
{   11.50	,   11.50	,   11.16	,   11.16   ,	10.58   ,	10.58   ,	10.13   ,	11.50	,   11.50	,   11.50   },      /*500 rpm*/      
{   11.50	,   11.50	,   11.16	,   11.16   ,	10.58   ,	10.58   ,	10.13   ,	11.50	,   11.50	,   11.50   },      /*600 rpm*/ 
{   11.50	,   11.50	,   11.16	,   11.16   ,	11.16   ,	11.16	,   11.50	,   11.50	,   11.50	,   11.50   },      /*700 rpm*/
{   11.50	,   11.50	,   11.16   ,	11.16	,   10.58   ,	10.58   ,	10.13   ,	11.50	,   11.50	,   11.50   },      /*800 rpm*/
{   11.50	,   11.50	,   11.16	,   11.16   ,	10.58   ,	10.58   ,	10.13   ,	11.50	,   11.50	,   11.50   },      /*900 rpm*/
{   11.50	,   11.50	,   11.16	,   11.16   ,	10.58   ,	10.58   ,	10.13   ,	11.50	,   11.50	,   11.50   },      /*1000 rpm*/       
{   11.50	,   11.50	,   11.16	,   11.16   ,	10.58   ,	10.58   ,	10.13   ,	11.50	,   11.50	,   11.50   },      /*1100 rpm*/    
{   11.50	,   11.50	,   11.16	,   11.16   ,	10.58   ,	10.58   ,	10.13   ,	11.50	,   11.50	,   11.50   },      /*1200 rpm*/ 
{   11.50	,   11.50	,   11.33	,   11.33	,   10.37	,   10.37	,   10.13	,   11.83	,   11.83	,   11.83   },      /*1300 rpm*/ 
{   11.50	,   11.50	,   11.33	,   11.33   ,  	10.37	,   10.37	,   10.13	,   12.16	,   12.16   ,	12.16   },      /*1400 rpm*/ 
{   11.50	,   11.50   ,	11.50	,   11.50	,   10.13   ,	10.13   ,	10.13   ,	12.50	,   12.50	,   12.50   },      /*1500 rpm*/ 
{   11.50	,   11.50	,   11.50	,   11.50	,   10.13	,   10.13   ,	10.13   , 	12.83	,   12.83   ,	12.83   },      /*1600 rpm*/ 
{   11.16	,   11.16	,   11.50	,   11.50	,   10.13	,   10.13	,    5.71	,   12.83   ,	12.66	,   12.66   },      /*1700 rpm*/ 
{   11.00	,   11.00   , 	11.50	,   11.50	,    9.85	,    9.85	,    6.75	,   12.66	,   12.33   ,	12.33   },      /*1800 rpm*/ 
{   10.83	,   10.83   ,	11.66   ,	11.66	,    9.85   ,	 9.53   ,	 7.55	,   12.50	,   12.00	,   12.00   },      /*1900 rpm*/ 
{   10.83	,   10.83   , 	11.66	,   11.66	,    9.53	,    9.16	,    8.20	,   12.33   ,   11.50	,   11.50   },      /*2000 rpm*/ 
{   10.83   ,  	10.83   ,  	11.66   , 	11.66   ,	 9.16	,    8.20	,    8.72	,   12.00	,   11.16	,   11.16   },      /*2100 rpm*/
{   10.83   ,	10.83   ,	11.50	,   11.50	,    9.53   ,	 9.16	,    9.16	,   11.83   ,	11.16	,   11.16   },      /*2200 rpm*/
{   10.83	,   10.83   ,	11.33	,   11.33   ,	10.13   ,	 9.53	,    9.53	,   11.50	,   11.16	,   11.16   },      /*2300 rpm*/
{   10.83	,   10.83	,   11.16   ,	11.16   ,	10.37	,   10.13	,   10.13	,   11.16	,   11.16	,   11.16   },      /*2400 rpm*/
{   10.83   , 	10.83   ,	11.00	,   11.00	,   10.58	,   10.58	,   10.58   ,	10.83   ,	11.16   ,	11.16   },      /*2500 rpm*/
{   10.83   ,	10.83   ,	10.83   ,	10.83   ,   10.58 	,   10.77   ,	10.77	,   10.50	,   11.16	,   11.16   },      /*2600 rpm*/
{   10.83   ,	10.83   ,	10.83   ,	10.83   ,   10.58 	,   10.77   ,	10.77	,   10.50	,   11.16	,   11.16   },      /*2700 rpm*/          
{   10.66   ,	10.66   ,	10.66   ,	10.66   ,	10.77   ,	10.94   ,	10.94   ,	10.66   ,	11.00	,   11.00   },      /*2800 rpm*/
{   10.66	,   10.66   ,	10.66   ,	10.66   ,	10.77   ,	11.23   ,	11.23   ,	10.50	,   10.83	,   10.83   },      /*2900 rpm*/
{   10.50	,   10.50	,   10.50	,   10.66	,   10.94   ,	11.47   ,	11.47   ,	10.33	,   10.50	,   10.50   },      /*3000 rpm*/
{   10.33	,   10.33	,   10.33	,   10.66	,   11.10	,   11.68	,   11.58	,   10.16	,   10.33	,   10.33   },      /*3100 rpm*/
{   10.33	,   10.33	,   10.33   ,	10.66	,   11.10	,   11.58	,   11.23	,   10.50	,   10.50	,   10.50   },      /*3200 rpm*/
{   10.33	,   10.33	,   10.33	,   10.83   ,	10.94	,   11.36   ,	10.94	,   10.83	,   10.83	,   10.83   },      /*3300 rpm*/
{   10.33	,   10.33	,   10.33   , 	11.16   ,	10.58	,   11.10	,   10.58	,   11.16	,   11.16	,   11.16   },      /*3400 rpm*/
{   10.33   ,	10.33	,   10.33   ,	11.33	,   10.37	,   10.77	,   10.13	,   11.50	,   11.50	,   11.50   },      /*3500 rpm*/
{   10.33	,   10.33	,   10.33	,   11.50	,   10.13	,   10.37	,    9.53	,   11.83	,   11.83	,   11.83   },      /*3600 rpm*/
{   10.33	,   10.33	,   10.33	,   11.50	,   10.13	,   10.37	,    9.53	,   11.83	,   11.83	,   11.66   },      /*3700 rpm*/
{   10.33	,   10.33	,   10.33	,   11.33	,   10.37	,   10.58	,    9.85	,   11.66	,   11.66	,   11.50   },      /*3800 rpm*/
{   10.33	,   10.33	,   10.33	,   11.33	,   10.37	,   10.77	,   10.13	,   11.50	,   11.50	,   11.33   },      /*3900 rpm*/
{   10.33	,   10.33	,   10.33	,   11.16	,   10.58	,   10.94	,   10.37	,   11.33	,   11.33	,   11.16   },      /*4000 rpm*/
{   10.33	,   10.33	,   10.33	,   11.16	,   10.58	,   11.10	,   10.58	,   11.16	,   11.16	,   11.16   },      /*4100 rpm*/
{   10.50	,   10.50	,   10.50	,   11.16	,   10.58	,   11.10	,   10.58	,   11.16	,   11.16	,   11.16   },      /*4200 rpm*/
{   10.50	,   10.50	,   10.50	,   11.16	,   10.58	,   11.23	,   10.77	,   11.00	,   11.16	,   11.16   },      /*4300 rpm*/
{   10.66   ,	10.66	,   10.66	,   11.00	,   10.77	,   11.23	,   10.77	,   11.00	,   11.00	,   11.00   },      /*4400 rpm*/
{   10.66	,   10.66	,   10.66	,   11.00	,   10.77	,   11.23	,   10.94	,   10.83	,   11.00	,   11.00   },      /*4500 rpm*/
{   10.83	,   10.83	,   10.83	,   10.83	,   10.94	,   11.23	,   11.10	,   10.66	,   11.00	,   11.00   },      /*4600 rpm*/
{   10.83	,   10.83	,   10.83	,   10.83	,   10.94	,   11.23	,   11.10	,   10.66	,   11.00	,   11.00   },      /*4700 rpm*/
{   10.83	,   10.83	,   10.83	,   10.83	,   10.94	,   11.23	,   11.10	,   10.66	,   11.00	,   11.00   },      /*4800 rpm*/
{   10.83	,   10.83	,   10.83	,   10.83	,   10.94	,   11.10	,   11.10	,   10.66	,   11.00	,   11.00   },      /*4900 rpm*/
{   10.83	,   10.83	,   10.83	,   10.83	,   10.94	,   11.10	,   11.10	,   10.66	,   11.00	,   11.00   },      /*5000 rpm*/
{   10.83	,   10.83	,   10.83	,   10.83	,   10.94	,   11.10	,   11.10	,   10.66	,   11.00	,   11.00   },      /*5100 rpm*/
{   10.83	,   10.83	,   10.83	,   10.83	,   10.94	,   11.10	,   11.10	,   10.66	,   11.00	,   11.00   },      /*5200 rpm*/
{   10.83	,   10.83	,   10.83	,   10.83	,   10.94	,   11.10	,   11.10	,   10.66	,   11.00	,   11.00   },      /*5300 rpm*/
{   10.83	,   10.83	,   10.83	,   10.83	,   10.94	,   11.10	,   11.10	,   10.66	,   11.00	,   11.00   },      /*5400 rpm*/
{   10.83	,   10.83	,   10.83	,   10.83	,   10.94	,   11.10	,   11.10	,   10.66	,   11.00	,   11.00   },      /*5500 rpm*/
{   10.83	,   10.83	,   10.83	,   10.83	,   10.94	,   11.10	,   11.10	,   10.66	,   11.00	,   11.00   },      /*5600 rpm*/
{   10.83	,   10.83	,   10.83	,   10.83	,   10.94	,   11.10	,   11.10	,   10.66	,   11.00	,   11.00   },      /*5700 rpm*/
{   10.83	,   10.83	,   10.83	,   10.83	,   10.94	,   11.10	,   11.10	,   10.66	,   11.00	,   11.00   },      /*5800 rpm*/
{   10.83	,   10.83	,   10.83	,   10.83	,   10.94	,   11.10	,   11.10	,   10.66	,   11.00	,   11.00   },      /*5900 rpm*/
{   10.83	,   10.83	,   10.83	,   10.83	,   10.94	,   11.10	,   11.10	,   10.66	,   11.00	,   11.00   },      /*6000 rpm*/
{   10.83	,   10.83	,   10.83	,   10.83	,   10.94	,   11.10	,   11.10	,   10.66	,   11.00	,   11.00   },      /*6100 rpm*/
{   11.00	,   11.00	,   11.00	,   11.00	,   10.77	,   10.94	,   10.94	,   10.83	,   11.16	,   11.16   },      /*6200 rpm*/
{   11.16	,   11.16	,   11.16	,   11.16	,   10.58	,   10.77	,   10.77	,   11.00	,   11.33	,   11.33   },      /*6300 rpm*/
{   11.33	,   11.33	,   11.33	,   11.33	,   10.37	,   10.58	,   10.58	,   11.16	,   11.50	,   11.50   },      /*6400 rpm*/
{   11.66	,   11.66	,   11.66	,   11.66	,    9.85	,    9.85	,    9.85	,   11.66	,   11.66	,   11.66   }};     /*6500 rpm*/



//const float ij_ref[66] = { 200.00 , 12.42 , 12.42 , 12.42 , 12.42 , 12.42 , 12.42 ,
//    12.42 , 12.42 , 12.42 , 12.42 , 12.60 , 12.78 , 12.97 , 13.16 , 13.35 , 13.55 ,
//    13.75 , 13.96 , 14.16 , 14.37 , 14.58 , 14.80 , 15.01 , 15.23 , 15.44 , 15.66 ,
//    15.87 , 16.09 , 16.31 , 16.52 , 16.74 , 16.95 , 17.16 , 17.37 , 17.58 , 17.78 ,
//    17.99 , 18.19 , 18.38 , 18.57 , 18.76 , 18.94 , 19.12 , 19.30 , 19.47 , 19.63 ,
//    19.79 , 19.94 , 20.08 , 20.22 , 20.35 , 20.48 , 20.60 , 20.70 , 20.80 , 20.90 ,
//    20.98 , 21.05 , 21.12 , 21.17 , 21.22 , 21.25 , 21.28 , 21.29 , 200.00 };

const float ij_ref[66] = { 200.00 , 17.42 , 17.42 , 17.42 , 17.42 , 17.42 , 17.42 ,
    17.42 , 17.42 , 17.42 , 17.42 , 17.60 , 17.78 , 17.97 , 18.16 , 18.35 , 18.55 ,
    18.75 , 18.96 , 19.16 , 19.37 , 19.58 , 19.80 , 20.01 , 20.23 , 20.44 , 20.66 ,
    20.87 , 21.09 , 21.31 , 21.52 , 21.74 , 21.95 , 22.16 , 22.37 , 22.58 , 22.78 ,
    22.99 , 23.19 , 23.38 , 23.57 , 23.76 , 23.94 , 24.12 , 24.30 , 24.47 , 24.63 ,
    24.79 , 24.94 , 25.08 , 25.22 , 25.35 , 25.48 , 25.60 , 25.70 , 25.80 , 25.90 ,
    25.98 , 26.05 , 26.12 , 26.17 , 26.22 , 26.25 , 26.28 , 26.29 , 200.00 };

//char Vet_TempAg[256] = {
//     116,107,101,98,95,92,90,88,86,85,84,83,81,80,79,78,78,77,76,75,
//     75,74,73,73,72,71,71,70,70,69,69,68,68,67,67,67,66,66,65,65,
//     65,64,64,63,63,63,62,62,62,61,61,61,60,60,60,59,59,59,59,58,
//     58,58,57,57,57,57,56,56,56,55,55,55,55,54,54,54,54,53,53,53,
//     53,52,52,52,52,52,51,51,51,51,50,50,50,50,50,49,49,49,49,48,
//     48,48,48,48,47,47,47,47,46,46,46,46,46,45,45,45,45,45,44,44,
//     44,44,44,43,43,43,43,43,42,42,42,42,41,41,41,41,41,40,40,40,
//     40,40,39,39,39,39,39,38,38,38,38,37,37,37,37,37,36,36,36,36,
//     36,35,35,35,35,34,34,34,34,33,33,33,33,33,32,32,32,32,31,31,
//     31,31,30,30,30,30,29,29,29,28,28,28,28,27,27,27,27,26,26,26,
//     25,25,25,24,24,24,23,23,23,22,22,22,21,21,21,20,20,19,19,18,
//     18,18,17,17,16,16,15,15,14,14,13,12,12,11,10,10,9,8,7,7,6,5,
//     4,3,1,0,-0,-2,-4,-6,-8,-11,-15,-21,-30};
//
//unsigned int Vet_TempAr[256] = {
//     383,374,370,366,364,361,359,358,356,355,354,353,352,351,350,349,348,348,347,346,
//     346,345,345,344,343,343,342,342,342,341,341,340,340,339,339,339,338,338,337,337,
//     337,336,336,336,335,335,335,335,334,334,334,333,333,333,333,332,332,332,331,331,
//     331,331,330,330,330,330,329,329,329,329,329,328,328,328,328,327,327,327,327,327,
//     326,326,326,326,325,325,325,325,325,324,324,324,324,324,323,323,323,323,323,322,
//     322,322,322,322,321,321,321,321,321,321,320,320,320,320,320,319,319,319,319,319,
//     318,318,318,318,318,318,317,317,317,317,317,316,316,316,316,316,316,315,315,315,
//     315,315,314,314,314,314,314,313,313,313,313,313,312,312,312,312,312,312,311,311,
//     311,311,311,310,310,310,310,310,309,309,309,309,308,308,308,308,308,307,307,307,
//     307,307,306,306,306,306,305,305,305,305,304,304,304,304,303,303,303,303,302,302,
//     302,302,301,301,301,300,300,300,300,299,299,299,298,298,298,297,297,296,296,296,
//     295,295,295,294,294,293,293,292,292,291,291,290,290,289,289,288,287,287,286,285,
//     284,283,283,282,280,279,278,277,275,273,271,268,265,260,252};

unsigned int Vet_TempAr[256] = {
     443,430,422,416,412,408,405,402,400,398,396,394,393,391,390,389,387,386,385,384,
     383,382,381,380,379,378,378,377,376,375,375,374,373,373,372,371,371,370,369,369,
     368,368,367,367,366,366,365,365,364,364,363,363,362,362,361,361,361,360,360,359,
     359,358,358,358,357,357,356,356,356,355,355,355,354,354,353,353,353,352,352,352,
     351,351,351,350,350,350,349,349,349,348,348,348,347,347,347,346,346,346,345,345,
     345,344,344,344,343,343,343,343,342,342,342,341,341,341,340,340,340,340,339,339,
     339,338,338,338,337,337,337,336,336,336,336,335,335,335,334,334,334,333,333,333,
     333,332,332,332,331,331,331,330,330,330,330,329,329,329,328,328,328,327,327,327,
     326,326,326,325,325,325,324,324,324,323,323,323,322,322,322,321,321,321,320,320,
     320,319,319,318,318,318,317,317,317,316,316,315,315,315,314,314,313,313,312,312,
     312,311,311,310,310,309,309,308,308,307,307,306,306,305,305,304,304,303,302,302,
     301,300,300,299,298,298,297,296,295,295,294,293,292,291,290,289,288,287,286,284,
     283,282,280,279,277,275,273,271,268,265,261,257,251,243,230};

char Vet_TempAg[256] = {
     154,142,135,130,126,123,121,118,116,115,113,111,110,109,107,106,105,104,103,102,
     101,101,100,99,98,98,97,96,95,95,94,94,93,92,92,91,91,90,90,89,
     89,88,88,87,87,87,86,86,85,85,84,84,84,83,83,82,82,82,81,81,81,
     80,80,80,79,79,78,78,78,77,77,77,77,76,76,76,75,75,75,74,74,74,
     73,73,73,73,72,72,72,71,71,71,71,70,70,70,69,69,69,69,68,68,68,
     68,67,67,67,66,66,66,66,65,65,65,65,64,64,64,64,63,63,63,62,62,
     62,62,61,61,61,61,60,60,60,60,59,59,59,59,58,58,58,58,57,57,57,
     56,56,56,56,55,55,55,55,54,54,54,54,53,53,53,52,52,52,52,51,51,
     51,50,50,50,50,49,49,49,48,48,48,47,47,47,47,46,46,46,45,45,45,
     44,44,44,43,43,43,42,42,41,41,41,40,40,40,39,39,38,38,38,37,37,
     36,36,35,35,35,34,34,33,33,32,32,31,30,30,29,29,28,28,27,26,26,
     25,24,23,23,22,21,20,19,18,17,16,15,14,12,11,9,8,6,4,2,-0,-3,-7,
     -12,-19,-30,};

float VetBat[147] = {3.21, 3.19, 3.16 ,3.14 ,3.11 ,3.08	,3.06 ,3.03 ,3.01 ,
                     2.98	,2.96 ,2.94 ,2.91 ,2.89	,2.86 ,2.84 ,2.82 ,2.79,
                     2.77 ,2.75 ,2.73 ,2.70	,2.68 ,2.66 ,2.64 ,2.62	,2.59 ,
                     2.57 ,2.55 ,2.53	,2.51 ,2.49 ,2.47 ,2.45	,2.43 ,2.41,
                     2.39 ,2.37	,2.35 ,2.33 ,2.31 ,2.29	,2.27 ,2.25 ,2.24 ,
                     2.22	,2.20 ,2.18 ,2.16 ,2.15	,2.13 ,2.11 ,2.09 ,2.08,
                     2.06 ,2.04 ,2.03 ,2.01	,1.99 ,1.98 ,1.96 ,1.94	,1.93,
                     1.91 ,1.90 ,1.88	,1.86 ,1.85 ,1.83 ,1.82	,1.80 ,1.79,
                     1.77 ,1.76	,1.75 ,1.73 ,1.72 ,1.70	,1.69 ,1.68 ,1.66 ,
                     1.65	,1.63 ,1.62 ,1.61 ,1.59	,1.58 ,1.57 ,1.56 ,1.54,
                     1.53 ,1.52 ,1.50 ,1.49	,1.48 ,1.47 ,1.46 ,1.44	,1.43,
                     1.42 ,1.41 ,1.40	,1.39 ,1.37 ,1.36 ,1.35 ,1.34 ,1.33,
                     1.32 ,1.31	,1.30 ,1.29 ,1.28 ,1.27	,1.25 ,1.24 ,1.23,
                     1.22,1.21 ,1.20 ,1.19 ,1.18,1.17 ,1.17 ,1.16 ,1.15	,
                     1.14 ,1.13 ,1.12 ,1.11	,1.10 ,1.09 ,1.08 ,1.07	,1.06 ,
                     1.06 ,1.05 ,1.04	,1.03 ,1.02 ,1.01 ,1.00	,1.00 ,0.99,
                     0.98 ,0.97	,0.96 };

/************************************** MAPA Tempo de injeção durante a partida *****************************************/
unsigned char VetTempo_Inj_Partida[11] = { 90, 90, 95, 95, 95, 95, 100, 100, 125, 165, 175 }; // ==> TempoInj/20
                                        /* 0%  10% 20%  30%  40%  50%  60%  70%  80%  90% 100% ==> %ETANOL */
/********************************** FIM MAPA Tempo de injeção ***********************************************************/

void SPI_MASTER1_Chip()                   //Slecionar modo mestre
{
  SSP1CON1 = 0b00100000;                    //habilita modo SPI // FOSC/4 //
  SSP1STAT = 0b01000000;              //pega amostras no fim do bit e a trasmissão será na borda de descida
  TRISC3 = 0;                         //C3 = SCK out/ C4 = SD1 in/ C5 = SDO out
  TRISC4 = 1;
  TRISC5 = 0;
}

#define Time_SPI    60

/***************************************** CONFIGURA HARDWARE ***********************************/
void Configure_HW()
{
   /* Configuração das Portas */
   TRISA = 0b00111111;  //TRISA = 0b00100111;
   TRISB = 0b00111011;  //TRISB = 0b11111111;
   TRISC = 0b10010000;  //TRISC = 0b00010000;
   TRISD = 0b01101000;  //TRISD = 0b00000000;
   TRISE = 0b00000001;  //TRISE = 0b00000000;
   __delay_us(50); //Para aguardar os tris acima >> reduziu falhas
   //__delay_ms(10); //Para aguardar os tris acima >> reduziu falhas

    //ANSELA = 0b00101110;          /*0010 1110 AN0,AN1,AN2,AN4*/
    ANSELA = 0x00;
    ANSELB = 0x00;
    ANSELC = 0x00;
    ANSELD = 0x00;
    ANSELE = 0x00;
    //__delay_ms(10); //Para aguardar os tris acima >> reduziu falhas

    Config_ADC();
    SPI_MASTER1_Chip();
    SPI_MASTER2();
    Config_Timer0();
    Config_Timer1();
    Config_Timer2();
    PR2 = 195;
    Config_Timer3();
    Config_Int_Ext0();
    Config_Timer5();
    Config_CCP1();
}
/***************************************** Interrupts *******************************************/
void interrupt high_isr(void)
{
    __EXT_INTERRUPT0__
    {
        Disable_ExtInt(nExt_Int0);
        Clear_ExtInt_Flag(nFLAG_ExtInt0);


        if (dente != 255)
        {
            Disable_Interrupt(nINT_TIMER1);
            Enable_Interrupt(nINT_TIMER2);
             t_periodo = Get_Timer1();
        }

        if ((t_periodo > t_periodo_ref) && (dente > 50))
        {
            /*------------------ Nova Volta -------------------------- */
             nSINAL_FALHA = nPin_HIGH; /* Sinal de Falha */
             falha_ok = 1;
             dente = 0; /* Reinicia contagem dos dentes */
             nRELE_BOMB_INJ = nPin_HIGH; // liga rele da bomba
            a = b = c = d = 0;
            /*------------------ Fim Nova Volta ----------------------- */
        }

          t_periodo = t_periodo << 1;              
          t_periodo_ref = t_periodo;

          conta_dente();

          Set_Timer1(0); // Inicia medicao do t_low
          ClearFlag_Interrupt(nFLAG_TMR1);
          Enable_Interrupt(nINT_TIMER1);

          if (dente == 2)       nSINAL_FALHA = nPin_LOW; /* Baixa o Pulso de Falha */

          c = 1;

          Enable_ExtInt(nExt_Int0);
    }

    __Interrupt_TMR3__
    {
        Disable_Interrupt(nINT_TIMER3);
        ClearFlag_Interrupt(nFLAG_TMR3);
        Enable_Interrupt(nINT_CCP1);
        //if(rotacao > 1600)  volta_spi = 1;
                            
        if(volta_spi)
        {
//           nPin_TESTE = nPin_HIGH; Hiroki
           map_ad_Read();
           t_ar_ad_Read();
           t_agua_ad_Read();
           Battery_ad_Read();
           if(rotacao < 1500) Comb_CCP_Read();           
                               
            if(Send_Spi)
            {
                
                nSINAL_SS_SINC = nPin_LOW;
                nSINAL_SS_ADM = nPin_HIGH;
                nSINAL_SS_COM = nPin_HIGH;
                nSINAL_SS_33810 = nPin_HIGH;
                nSINAL_SS_33972 = nPin_HIGH;
                
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE1(ig_dente_14);
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE1(ig_tmr_disparo);
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE1(ij_dente_14);
                __delay_us(Time_SPI);
                Spi_Write16(ij_tmr_disparo);
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE1(tempo_bob);
                __delay_us(Time_SPI);
                Spi_Write16(tempo_inj);
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE1(address); //Envia o RPM
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE1(ij_dente_14_extra);
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE1(t_agua);
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE1(sensor_Comb_Flex); //Percentual Álcool na mistura //ANTONIO FERREIRA
                __delay_us(Time_SPI);
                
                nSINAL_SS_SINC = nPin_HIGH;
                nSINAL_SS_33810 = nPin_HIGH;
                nSINAL_SS_33972 = nPin_HIGH;
                nSINAL_SS_ADM = nPin_HIGH;

                nSINAL_SS_COM = nPin_LOW;
                __delay_us(Time_SPI);
                Spi2_Write16(rotacao);          //1-2
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE2(pedal_ad);    //3
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE2(map);         //4
//                __delay_us(Time_SPI);
//                MASTER_SPI_WRITE2(tempo_bob); //
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE2(lambda); //5
                __delay_us(Time_SPI);
                Spi2_Write16(tempo_Inj_com);        //6-7
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE2(t_ar_com);  //8
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE2(t_agua);  //9 
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE2(ref_vb); //10
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE2(sensor_Comb_Flex); //11  //ANTONIO FERREIRA
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE2(Estequiometria/10); //12 //ANTONIO FERREIRA
                __delay_us(Time_SPI);
                nSINAL_SS_COM = nPin_HIGH;
                
                nSINAL_SS_SINC = nPin_HIGH;
                nSINAL_SS_ADM = nPin_LOW;
                nSINAL_SS_COM = nPin_HIGH;
                __delay_us(Time_SPI);
                MASTER_SPI_WRITE1(ref_vb);
                __delay_us(Time_SPI);
                nSINAL_SS_SINC = nPin_HIGH;
                nSINAL_SS_ADM = nPin_HIGH;
                nSINAL_SS_COM = nPin_HIGH;
               
                Send_Spi = 0;
//                nPin_TESTE = nPin_LOW; Hiroki
            }
                          
           // Calculo da rotacao
           rotacao_temp_1 = 5000.0 / (float)periodo;
           rotacao_temp = rotacao_temp_1 * 1000.0;
           rotacao = (unsigned int)(rotacao_temp);

            // Calculo dos indices de referencia para leitura dos adiantamentos
            if (rotacao > 6500)     address = 65;
            else       address = (unsigned char)(rotacao_temp / 100);

            if (rotacao > 600) //Rotação > 500 Original
            {
                 //Rotinas ECU Freescale para injeção
                 //m_ar = (1727.707/*Const_Gases*/ * pressao_ar)/t_ar; //em mg para facilitar contas
                 /*
                  *1727.707 é a constante gerada pela função de massa dos gases sendo para 2.0L
                  * m_ar = (1727.707*pressao_ar)/t_ar; //em mg para facilitar contas
                  *
                  * 1.6L = 1379.379
                  */
                 m_ar = (Const_Gases * pressao_ar)/t_ar; //em mg para facilitar contas HIROKI

                //m_comb = m_ar / 13.3; //13.3;//12.7 Rotina ECU Freescale    em mg!!!    12.7 é a estequiometria Fluxo:176.93g/min
                 m_comb = m_ar / (Estequiometria/100); //13.3;//12.7 Rotina ECU Freescale    em mg!!!    12.7 é a estequiometria Fluxo:176.93g/min
                 tempo_inj_temp_1 = m_comb * Vazao_InjGOL; //Teste para funcionar map variando injecao
                 //m_comb = m_ar / 12.7; //Rotina ECU Freescale    em mg!!!    12.7 é a estequiometria Fluxo:176.93g/min HIROKI
                 //tempo_inj_temp_1 = m_comb * Vazao_InjGOL; //Teste para funcionar map variando injecao HIROKI
                 
                 // Ajuste do fator de injecao em caso de aceleracao/desaceleracao
                 fator_inj = 1.0 /*+ Kp_inj*erro_rpm*/;       //HIROKI

                 if (t_agua < 70.0)    fator_inj += 0.28 - 0.004*t_agua;
                 else fator_inj = 1.0;

                 // Limitacao superior do fator de injecao (equivale a lambda ~ 0.71)
                 if (fator_inj > 1.4)     fator_inj = 1.4;

                 // Limitacao inferior do fator de injecao (equivale a lambda ~ 1.33)
                 else if (fator_inj < 0.75)      fator_inj = 0.75;

                 /*tempo_inj_temp = (tempo_inj_temp_1 * fator_inj) * 100;*/
                 tempo_inj_temp = (tempo_inj_temp_1 * fator_inj);     //HIROKI 
                 tempo_inj_temp = tempo_inj_temp * 0.75;
                 
                 if(ref_rpm > 2000)
                 {
                     fator_inj_Aceleracao = 1.05 + (ref_rpm/10000);
                     tempo_inj_temp = tempo_inj_temp * fator_inj_Aceleracao;
                 }

                // Limita o tempo de injecao entre 2.7ms e 18.0 ms
                if (tempo_inj_temp < nMIN_TIME_INJGOL)        tempo_inj_temp = (nMIN_TIME_INJGOL); //Mínimo de injecao
                else if (tempo_inj_temp > nMAX_TIME_INJGOL)   tempo_inj_temp = (nMAX_TIME_INJGOL); //Maximo de inj
                
                //if (tempo_inj_temp < (nMIN_TIME_INJGOL))        tempo_inj_temp = (nMIN_TIME_INJGOL); //Mínimo de injecao HIROKI
                //else if (tempo_inj_temp > (nMAX_TIME_INJGOL))   tempo_inj_temp = (nMAX_TIME_INJGOL); //Maximo de inj     HIROKI
                
                
                // Limitacao superior do tempo de injecao com base no periodo de rotacao
                //periodo_52 = (periodo * 10.4) + (ij_ref[address] * periodo / 5.0);

                //tempo_inj_temp = 18000.0;
                //Controle da inj extra
                /*t_inj_real = (tempo_inj_temp/100);*/
                t_inj_real = tempo_inj_temp;

                periodo_52 = (periodo * 10.4);

                if (tempo_inj_temp > periodo_52)
                {
                    /*tempo_inj_temp = (long int)(periodo_52 * 100);*/
                    tempo_inj_temp = periodo_52;
                    t_inj_lim = (tempo_inj_temp);

                    t_inj_extra = (int)(t_inj_real - t_inj_lim);
                }
                else t_inj_extra = 0.0;

                // Calculo do tempo de carregamento da bobina de ign
                tempo_bob_temp = Bob_TimingGOL;            //HIROKI
                //Flag_MarchaLenta = 0;
             }
             else
             {
                    tempo_inj_temp = 4000;
                    tempo_Inj_com = tempo_inj_temp;
                    tempo_bob_temp = Bob_TimingGOL;                                               //HIROKI
 
                
                /* Limita o tempo de injecao entre 2.7ms e 18.0 ms */
                if (tempo_inj_temp < nMIN_TIME_INJPART)        tempo_inj_temp = (nMIN_TIME_INJPART); //Mínimo de injecao
                else if (tempo_inj_temp > nMAX_TIME_INJPART)   tempo_inj_temp = (nMAX_TIME_INJPART); //Maximo de inj
                
                
             }                    
        }      
        else       //Volta_Spi
        {
//          nPin_TESTE = nPin_HIGH; Hiroki
           
            if (rotacao < 800)   ref_vb = nTPS_MIN;
            if (rotacao > 4000)  tempo_bob_temp = 4000.0;

            /* Le os avancos da memoria de programa */
            address = (unsigned char)(rotacao_temp * 0.01);

            if (pressao_ar < 30.0)         address_2 = 0;
            else if (pressao_ar > 120.0)   address_2 = 9;
            else                           address_2 = (unsigned char)((pressao_ar / 10) - 3);

            // Calculo dos adiantamentos - IGN e INJ
            periodo = periodo / 5.0;
            n = (tempo_inj_temp) / periodo;
            ij_14_temp = ij_ref[address] - n - 1.0;

            if (ij_14_temp < 1.0)    ij_14_temp += 60.0;

            ij_dente_14_temp = (int)ij_14_temp;

            if ((ij_dente_14_temp == 59) || (ij_dente_14_temp >= 60))        ij_dente_14_temp = 58; // Para o caso em que o sinal sobe na falha
            else if ((ij_dente_14_temp == 29) || (ij_dente_14_temp == 30))   ij_dente_14_temp = 28; // Para o caso em que o sinal de inj 23 sobe na falha

            ij_tmr_disparo_temp = (ij_14_temp - (float)ij_dente_14_temp)*periodo;

            //Dente de injeção extra
            if((t_inj_extra > 0.0) && (rotacao > 2600))
            {
                 n_e = t_inj_extra / periodo;
                 ij_14_extra = ij_14_temp - n_e;

                 if (ij_14_extra < 1.0)     ij_14_extra = 1.0;
                 if (ij_14_extra > 28.0)     ij_14_extra = 28.0;

                 ij_dente_14_extra = (int)ij_14_extra;
            }
            else ij_dente_14_extra = 0;

            n = tempo_bob_temp/periodo;
//            ig_14_temp = ig_refGOL_Gasolina[address][address_2] - n;        //Gustavo Hiroki
            
            ig_14_temp_Gasolina = ig_refGOL_Gasolina[address][address_2] - n; //Antonio Ferreira
            ig_14_temp_Etanol = ig_refGOL_Etanol[address][address_2] - n;     //Antonio Ferreira
            
            if((Percentual_Etanol != 0) || (Percentual_Gasolina != 0)) // É diferente de zero? se sim...
            {
                ig_14_temp = (Percentual_Etanol*ig_14_temp_Etanol) + (Percentual_Gasolina*ig_14_temp_Gasolina); //Média Ponderada para descobrir o avanço de ignição
                ig_14_temp = ig_14_temp/(Percentual_Etanol + Percentual_Gasolina);
            }
            else // Se não...
            {
                ig_14_temp = ig_refGOL_Gasolina[address][address_2] - n;      //Gustavo Hiroki
            }
            
              if(rotacao > 600) ig_14_temp += controle_Avn_marchaLenta();
            
            if (ig_14_temp < 1.0)    ig_14_temp += 60.0;

            ig_dente_14_temp = (int)ig_14_temp;

            if ((ig_dente_14_temp == 59) || (ig_dente_14_temp >= 60))           ig_dente_14_temp = 58; // Para o caso em que o sinal sobe na falha
            else if ((ig_dente_14_temp == 29) || (ig_dente_14_temp == 30))      ig_dente_14_temp = 28; // Para o caso em que o sinal de ign 23 sobe na falha

            ig_tmr_disparo_temp = (ig_14_temp - (float)ig_dente_14_temp)*periodo;

            // Limite inferior para tempos de disparo da ign e inj (impede erros no Sinc)
            if (ij_tmr_disparo_temp < 10.0)
                ij_tmr_disparo_temp = 10.0;

            if (ig_tmr_disparo_temp < 10.0)
                ig_tmr_disparo_temp = 10.0;

                // CUT-OFF - Corta a injecao em caso de desaceleracoes razoaveis ou rotacoes acima de 6000 rpm
                // OBS: Abaixo de ~2000 RPM nao se corta a injecao (ajuda na estabilizacao da marcha lenta apos desaceleracao)
                if (((erro_rpm < -1000.0) && (rotacao > 1300)) || (rotacao > 6050))
                {
                    ij_dente_14_temp = 200.0;
                    ij_tmr_disparo_temp = 0;
                    tempo_inj_temp = 0;
                }

               ig_dente_14 = ig_dente_14_temp;
               ij_dente_14 = ij_dente_14_temp;
               ig_tmr_disparo_temp = ig_tmr_disparo_temp / 52.0; //O 52 é para ajustar - OK

               if (ig_tmr_disparo_temp < 1)      ig_tmr_disparo_temp = 1.0;
               if (ij_tmr_disparo_temp < 1)      ij_tmr_disparo_temp = 1.0;

               ig_tmr_disparo = (int)ig_tmr_disparo_temp << 1;
               ij_tmr_disparo = (unsigned int)ij_tmr_disparo_temp;
               tempo_bob_temp = tempo_bob_temp / 52;
               tempo_bob = (int)tempo_bob_temp;
               tempo_Inj_com = tempo_inj_temp;
               tempo_inj_temp = ((tempo_inj_temp*100) / 80) * fator_corr_vbat;
               tempo_inj = (unsigned int)tempo_inj_temp;

                if(!PORTB5_nL15)    tempo_inj = 0;

            d = 1;
            Send_Spi = 1;             
//            nPin_TESTE = nPin_LOW; Hiroki
        }
        b = 1;    
        volta_spi = !volta_spi;
    }   /*END Timer3*/
    
      __Interrupt_CCP1__ 
    {
          Disable_Interrupt(nINT_CCP1);
          ClearFlag_Interrupt(nFLAG_CCP1);
          TMR5H = 0;    // Limpa o Timer 5 (Parte Alta)
          TMR5L = 0;    // Limpa o Timer 5 (Parte Baixa)
          Enable_Interrupt(nINT_CCP1);
    }
    /*END CCP1*/

} /*END high interrupt*/

void interrupt low_priority Low_Isr( void )
{
    __Interrupt_TMR1__
    {
        Disable_Interrupt(nINT_TIMER1);
        ClearFlag_Interrupt(nFLAG_TMR1);
        Disable_Interrupt(nINT_TIMER2);
        Enable_Interrupt(nINT_CCP1);

         rotacao = 0;
         falha_ok = 0;
         t_periodo_ref = 65535; // Reseta deteccao da falha
         t_periodo = 65530;
         dente = 255;
         if(Send_Spi_2) Send_Spi_2--;
         
//         if(!PORTB5_nL15)       nRELE_BOMB_INJ = nPin_LOW;// nPin_LOW;
//         else                   nRELE_BOMB_INJ = nPin_HIGH;
         

         if(!PORTB5_nL15)       
         {
             nRELE_BOMB_INJ = nPin_LOW;// nPin_LOW;
             Rele_bomb_Count = 255;
         }
         else
         {
             if(!Rele_bomb_Count)
             {
                 nRELE_BOMB_INJ = nPin_LOW;// nPin_LOW;
             }
             else
             {
                 Rele_bomb_Count--;
                 nRELE_BOMB_INJ = nPin_HIGH;
             }
         }

         pedal_ad_Read();
         t_agua_ad_Read();
         Comb_CCP_Read();
         
         ref_vb = pedal_ad;
         
        nSINAL_SS_SINC = nPin_HIGH;
        nSINAL_SS_ADM = nPin_LOW;
        nSINAL_SS_COM = nPin_HIGH;
        __delay_us(Time_SPI);
        MASTER_SPI_WRITE1(ref_vb);
        __delay_us(Time_SPI);
        nSINAL_SS_SINC = nPin_HIGH;
        nSINAL_SS_ADM = nPin_HIGH;
        nSINAL_SS_COM = nPin_HIGH;
        
        if(!Send_Spi_2)
        {
            Send_Spi_2 = 10;
            nSINAL_SS_SINC = nPin_HIGH;
            nSINAL_SS_33810 = nPin_HIGH;
            nSINAL_SS_33972 = nPin_HIGH;
            nSINAL_SS_ADM = nPin_HIGH;

            nSINAL_SS_COM = nPin_LOW;
            __delay_us(Time_SPI);
            Spi2_Write16(rotacao);          //1-2
            __delay_us(Time_SPI);
            MASTER_SPI_WRITE2(pedal_ad);    //3
            __delay_us(Time_SPI);
            MASTER_SPI_WRITE2(map);         //4
            __delay_us(Time_SPI);
            MASTER_SPI_WRITE2(lambda);      //5       //ANTONIO FERREIRA
            __delay_us(Time_SPI);
            Spi2_Write16(tempo_inj);        //6-7
            __delay_us(Time_SPI);
            MASTER_SPI_WRITE2(t_ar_com);    //8
            __delay_us(Time_SPI);
            MASTER_SPI_WRITE2(t_agua);     //9 
            __delay_us(Time_SPI);
            MASTER_SPI_WRITE2(ref_vb);     //10
            __delay_us(Time_SPI);
            MASTER_SPI_WRITE2(sensor_Comb_Flex); //11  //ANTONIO FERREIRA
            __delay_us(Time_SPI);
            MASTER_SPI_WRITE2(Estequiometria/10); //12 //ANTONIO FERREIRA
            __delay_us(Time_SPI);
        }

         Enable_Interrupt(nINT_TIMER1);
    }   /*END Timer1*/
        
    __Interrupt_TMR2__
    {
        ClearFlag_Interrupt(nFLAG_TMR2);
           if (dm==0)
            {
                 pedal_ad_Read();
                 if (t_agua < 40.0)
                 {
                     rotacao_mlenta = 1200.0;
                 }
                 else if (t_agua > 70.0)   rotacao_mlenta = 900.0;
                 else   rotacao_mlenta = 1733.3 - (13.33 * t_agua);

             //Kref1_rpm = (6100.0 - rotacao_mlenta) /(nPEDAL_MAXPOLO - nPEDAL_MINPOLO);
             //Kref2_rpm = (-(6100.0 - rotacao_mlenta)*(nPEDAL_MINPOLO /(nPEDAL_MAXPOLO - nPEDAL_MINPOLO))) + rotacao_mlenta;
             Kref1_rpm = (6100.0 - rotacao_mlenta) /(nPEDAL_MAXGOL - nPEDAL_MINGOL);
             Kref2_rpm = (-(6100.0 - rotacao_mlenta)*(nPEDAL_MINGOL /(nPEDAL_MAXGOL - nPEDAL_MINGOL))) + rotacao_mlenta;
             
//             if(Flag_MarchaLenta == 1 && pedal_ad <= nPEDAL_MINGOL)
//             {
//               ref_rpm = 1000.0;       //HIROKI  
//             }
//             else    ref_rpm = Kref1_rpm*(float)pedal_ad + Kref2_rpm;       //HIROKI            
             ref_rpm = (Kref1_rpm*(float)pedal_ad + Kref2_rpm) - 200;       //HIROKI

                 if (ref_rpm < 900.0)         ref_rpm = 900.0;      // Limite inferior da referencia

                else if (ref_rpm > 6500.0)    ref_rpm = 6500.0;     // Limite superior da referencia

            controle_rpm();
            dm = 1;
            }
            else dm = 0;      
    }   /*END Timer2*/
}   /*END low interrupt*/
/************************************************************************************************/

/*Envia 16 Bits via SPI*/
void Spi_Write16(unsigned int data)
{
   MASTER_SPI_WRITE1(data >> 8);
   __delay_us(Time_SPI);
   MASTER_SPI_WRITE1(data & 0x00FF);
}

/*Envia 16 Bits via SPI*/
void Spi2_Write16(unsigned int data)
{
   MASTER_SPI_WRITE2(data >> 8);
   __delay_us(Time_SPI);
   MASTER_SPI_WRITE2(data & 0x00FF);
}

/* Envia e le 16 bits via SPI - Usado para o MC33810 */
//long int spi_write_read_16(unsigned int data)
//{
//
//   int x, y;
//   nSINAL_SS_33810 = nPin_LOW;
//
//   __delay_us(1);
//   x = MASTER_SPI_WRITE1(data >> 8);
//   __delay_us(50);
//   y = MASTER_SPI_WRITE1(data & 0x00FF);     //Máscara para o byte mais significativo
//   __delay_us(1);
//
//   nSINAL_SS_33810 = nPin_HIGH;
//   __delay_us(50);
//   nSINAL_SS_33810 = nPin_LOW;
//
///*___________________________ Comando de leitura executado 2 vezes p/ funcionar _______________________________*/
//   __delay_us(1);
//   x = MASTER_SPI_WRITE1(data >> 8);
//   __delay_us(50);
//   y = MASTER_SPI_WRITE1(data & 0x00FF);
//   __delay_us(1);
//
//   nSINAL_SS_33810 = nPin_HIGH;
//
//   return (y >> 8)| x;
//}

/*__________________________________________ Funcao conta_dente _______________________________________________*/
inline void conta_dente()
{
   dente++; /* Contagem dos dentes */
   
   if (falha_ok == 0) // Inicia as medicoes e calculos somente apos detectar a falha ao menos uma vez
        return;

   if (dente == 2)
   {
      Set_Timer0(0);
   }

   if (dente == 3)
   {
     periodo = Get_Timer0();
     Set_Timer3(65036);
     ClearFlag_Interrupt(nFLAG_TMR3);
     Enable_Interrupt(nINT_TIMER3);
   }
   a = 1;
}

void lambda_ad_Read()
{
    lambda = (Read_ADC(AN_2));
}

void map_ad_Read()
{
   map = (Read_ADC(AN_5));
   //pressao_ar = ((map*0.493) - 3.86);
   pressao_ar = ((map*49) - 386)/100;//pressao_ar = ((map*49) - 386)/100;
     
   //pressao_ar = (0.442 * (float)map + 7.157)-20;   
   //pressao_ar = 0.442 * (float)map + 7.157;   // Unidade: kPa POLO
   //pressao_ar = 0.442 * (float)map + 7.157;   //GOL 
}

void t_ar_ad_Read()
{
   sensor_t_ar= Read_ADC(AN_11);
   t_ar = Vet_TempAr[sensor_t_ar];                          /*Valor de temperatura calculada em um vetor*/
   
   //rs = (float)(sensor_t_ar / (256.0 - sensor_t_ar));     //Unidade: KOhms        //Troca 255 to 256 avoid div by 0
   //t_ar = -27.25 * log(rs) + 44.52 + 273.15;              // Unidade: Kelvin POLO
   //t_ar = -44.24 * log(rs) + 63.848 + 273.15;             //GOL
   t_ar_com = (unsigned char) (t_ar - 273);
}

void t_agua_ad_Read()
{
   sensor_t_agua= Read_ADC(AN_4);
   t_agua = Vet_TempAg[sensor_t_agua];                      /*Valor de Temperatura calculada em um vetor*/
   
//   if(t_agua >= 78 )
//   {
//       Flag_MarchaLenta = 1;
//   }
//   else if(t_agua <= 70)
//   {
//      Flag_MarchaLenta = 0; 
//   }
      
   //rs = (float)(sensor_t_agua / (256.0 - sensor_t_agua)); // Unidade: KOhms    //Troca 255 to 256 avoid div by 0
   //t_agua = -30.57 * log(rs) + 43.01;                     // Unidade: Celsius POLO
   //t_agua = -38.38 * log(rs) + 61.69;/*GOL*/
}

void Battery_ad_Read()
{
   __delay_us(90);
   VoltBattery = Read_ADC(AN_8);
   VoltBattery = VoltBattery - 109;
   
    if (VoltBattery < 255) 
    {
        fator_corr_vbat = VetBat[VoltBattery];
        if (fator_corr_vbat < 1.0)    fator_corr_vbat = 1.0;
    }
}

void pedal_ad_Read()
{
    static unsigned int Soma = 0;
    static unsigned int Valores[10];
    static unsigned char i = 0,N = 0,Index;

    
//    for(Index = 0 ;Index < 5;Index++)
//    {  
      __delay_us(90);
      pedal_ad = Read_ADC(AN_0);

      if(pedal_ad <= nPEDAL_MINGOL)
      {
          pedal_ad = 38;
      }

//    /********************* FIM Média Móvel******************************************************/
}

void Comb_CCP_Read()
{
    static unsigned char Frequencia = 0;              // Frequencia gerada pelo sensor de Etanol
    static unsigned int periodo_CCP = 0;              // Periodo dos registradores CCPR1H + CCPR1L (em contagem)
    static unsigned int Soma = 0;
    static unsigned int Valores[10];
    static unsigned char i = 0,N = 0,Index;
//    static unsigned char Percentual_Etanol = 0;       // Frequencia gerada pelo sensor de Etanol
//    static unsigned char Percentual_Gasolina = 0;     // Frequencia gerada pelo sensor de Etanol
    
    periodo_CCP = (CCPR1H << 8) | CCPR1L;             // Os dois tempos sao unificados e carregados no variavel Tempo_CCP.
    Frequencia = 1/(periodo_CCP*0.0000008);           // Período do sinal =  CCPR1H+CCPR1L * Tempo de contagem do timer 5(800nsegundos)
                                                      // Frequência do sinal = 1 / Período do sinal
//    Disable_Interrupt(nINT_CCP1);
    
    /****Média Móvel --> Realiza filtragem no caso de pequenas variações de frequencias*********/
    Valores[i] = Frequencia;
    i = (i+1)%10;
    N = N < 10 ? N+1 : 10;
    Soma = 0;
    for(Index = 0 ;Index < N;Index++)
    {
      Soma = Soma + Valores[Index];
    }
    Frequencia = Soma/N;
    /********************* FIM Média Móvel******************************************************/
    
    if((Frequencia <= 150) && (Frequencia >= 50))     // Limites de frequencia que o sensor trabalha (50 Hz até 150 Hz)
    {
       sensor_Comb_Flex = Frequencia - 50;               // %ETANOL = Frequência do sinal - 50
       Percentual_Etanol = sensor_Comb_Flex/10;          // %ETANOL
       Percentual_Gasolina = 10 - (sensor_Comb_Flex/10); // %GASOLINA
       Estequiometria = (Percentual_Etanol*nEstequio_Etanol) + (Percentual_Gasolina*nEstequio_Gasolina); //Média Ponderada para descobrir a Estequiometria
       Old_Estequiometria = Estequiometria;              // Guarda o valor da estequiometria
       Old_Percentual_Etanol = Percentual_Etanol;
       Old_Percentual_Gasolina = Percentual_Gasolina;
    }
    else if((Frequencia >= 170) && (Frequencia <= 190))  // Limites de diagnóstico de falha (170 Hz até 190 Hz)
    {
        if(Old_Estequiometria)
        {
            Estequiometria      = Old_Estequiometria;
            Percentual_Etanol   = Old_Percentual_Etanol;
            Percentual_Gasolina = Old_Percentual_Gasolina;
        } // Se houver falha na leitura do sensor utiliza última estequiometria válida
        else
        { 
            Estequiometria = nEstequio_Media;
            Percentual_Etanol = 5;
            Percentual_Gasolina = 5;
        } // Sensor não entrou em funcionamento utiliza estequiometria média entre etanol e gasolina   
    }
    else
    {   
         Estequiometria = nEstequio_Media; // Sensor com frequencia abaixo de 50Hz utiliza estequiometria média entre etanol e gasolina   
         Percentual_Etanol = 5;
         Percentual_Gasolina = 5;
    }
}

float controle_Avn_marchaLenta()
{
    static const float Kp_ign = 0.02;                                            //Ganho P
    static const float Kd_ign = 0.003;                                           //Ganho D
    static const float Max_control = 1.5;                                        //Limitação superior do avanço
    static const float Min_control = -1.5;                                       //Limitação inferior do avanço
    float erro_rpm = 0;//Erro
    float control_P = 0, control_D = 0;                                          // Ação proporcional e derivativa do controle
    float _control = 0;                                                          //Sinal de controle
    static float erro_rpm_ant = 0;                                               //Erro Anterior
    
    /*Cálculo do erro*/
    erro_rpm  = (float)rotacao_mlenta - (float)rotacao;
    
    if((pedal_ad < REF_TORQUE_MLenta) &&(rotacao < rotacao_mlenta_control) && (rotacao > 700))
    {
        control_P =  Kp_ign * erro_rpm;
        control_D =  Kd_ign * (erro_rpm - erro_rpm_ant);
        _control = -(control_P + control_D);
        
        if(_control > Max_control)
        {
            _control = Max_control;
        }
        else if(_control < Min_control)
        {
            _control = Min_control;
        }
    }
    else
    {
        _control = 0;                                                            //Fora do regime de marcha lenta não corrige avanço
    }     
    erro_rpm_ant = erro_rpm;
    return _control;                                                             //Guardo os valores para o proximo laço
}

inline void controle_rpm()
{
    static float _control;
    static float ref_vb_temp;

    // Algoritmo de controle PI
    erro_rpm = ref_rpm - (float)rotacao;

    if ((erro_rpm < 70.0) && (erro_rpm > -70.0))       return;

    // Atualiza a somatoria
    if ((erro_rpm < 500.0) && (erro_rpm > -500.0))      soma_erro_rpm += erro_rpm;      // Integracao condicional - Anti wind-up
    else        soma_erro_rpm = 0; // Descarrega a somatoria

    // Anti wind-up (Limita a somatoria)
    if (soma_erro_rpm > 200000.0)             soma_erro_rpm = 200000.0;
    else if (soma_erro_rpm < -200000.0)       soma_erro_rpm = -200000.0;

        if (erro_rpm > 0.0)
        if (rotacao < 1700)            Kp_rpm = erro_rpm*0.08/5000.0; // Ajustar o primeiro parametro da formula
        else if (rotacao < 3000)       Kp_rpm = erro_rpm*(0.00013*(float)rotacao-0.142)/5000.0; // Ajustar o primeiro parametro da formula
        else                           Kp_rpm = erro_rpm*0.25/5000.0; // Ajustar o primeiro parametro da formula
        else                           Kp_rpm = 0.0;

        _control = Kp_rpm*erro_rpm + Ki_rpm * soma_erro_rpm;
        ref_vb_base = 0.006 * ref_rpm + 30.07; // Posicao da vb para manter a rotacao 0.0054
        ref_vb_temp = ref_vb_base + _control;

     // Limitacao da posicao max da vb para o motor nao "afogar" em aceleracoes grandes
//     if (rotacao < 1700)        ref_vb_max = 60.0;
//     else if(rotacao < 3000)
//     {
//        //ref_vb_max = (nTPS_MAXPOLO - 137.0)*((float)rotacao - 1700.0)/1300.0 + 137.0;
//        //if (ref_vb_max > nTPS_MAXPOLO)
//        //    ref_vb_max = ;
//         
//        ref_vb_max = (nTPS_MAXGOL - 60.0)*((float)rotacao - 1700.0)/1300.0 + 60.0;
//        //if (ref_vb_max > nTPS_MAXGOL)       ref_vb_max = nTPS_MAXGOL;
//     }
//     else if(rotacao < 5000)
//     {
//         ref_vb_max = nTPS_MAXGOL;
//         if (ref_vb_max > nTPS_MAXGOL)       ref_vb_max = nTPS_MAXGOL;
//     }
     if (rotacao < 1700)        ref_vb_max = 100.0;//137.0;
     else
     {
        //ref_vb_max = (nTPS_MAXPOLO - 137.0)*((float)rotacao - 1700.0)/1300.0 + 137.0;
        //if (ref_vb_max > nTPS_MAXPOLO)
        //    ref_vb_max = ;
         
        ref_vb_max = (nTPS_MAXGOL - 100.0)*((float)rotacao - 1700.0)/1300.0 + 100.0;
        if (ref_vb_max > nTPS_MAXGOL)
            ref_vb_max = nTPS_MAXGOL;
     }
     
     // Limita referencia para controle da borboleta
     if ((ref_vb_temp < nTPS_1000) && (rotacao > 1500))       ref_vb_temp = nTPS_1000;
     else if (ref_vb_temp < MIN_REFVB)                        ref_vb_temp = MIN_REFVB;        // Impede fechamento total da vb
     else if (ref_vb_temp > ref_vb_max)                       ref_vb_temp = ref_vb_max;  // Limitacao para o motor nao "afogar" em aceleracoes grandes
                  
     //ref_vb = (unsigned char)ref_vb_temp; // Passa p/ a variavel final
     
     ATUALref_vb = (unsigned char)ref_vb_temp; // Passa p/ a variavel final
     if(ATUALref_vb > (ANTref_vb << 1) || ATUALref_vb >= 100)
     {
         ATUALref_vb = ANTref_vb;
         ref_vb = ANTref_vb;
     }
     else  
     {
        ref_vb = (unsigned char)ref_vb_temp; // Passa p/ a variavel final 
        ANTref_vb = ref_vb;
     }
     
          
     injecao_ok = 0; // reseta a variavel
}

void Delay_ms(unsigned int value)
{
    unsigned int i;
    for(i = 0; i < value; i++)
    {
        __delay_ms(1);
    }
}

void main(void)
{   //nLED_TEST = 1;
   Configure_HW();

   //output_high(SS); //Pino E2 para o CS do PIC comunicação
   //LATBbits.LB1 = nPin_HIGH;
   nSINAL_SS_ADM = nPin_HIGH;
   nSINAL_SS_COM = nPin_HIGH;
   nSINAL_SS_SINC = nPin_HIGH;
   nSINAL_SS_33810 = nPin_HIGH;
   nSINAL_SS_33972 = nPin_HIGH;
   nBOMBA_CB = nPin_LOW;
   nLED_TEST = nPin_HIGH;
   nRELE_BOMB_INJ = nPin_LOW;

   ig_dente_14 = 200;
   ij_dente_14 = 200;
   ig_tmr_disparo = 0;
   ij_tmr_disparo = 0;
   tempo_inj = 0;
   tempo_bob = 0;
   t_periodo = 65530;       //Time 1ms to Timer3
   t_periodo_ref = 65535; /* Garante que o pulso de deteccao so acontecera apos
                            a comparacao do segundo pulso de sinal */
   dente = 255;
   rotacao = 0;
   falha_ok = 0;
   temp = 0;
   dm=0;
   volta_spi=0;

   IPEN = 1;          // Prioridade de Interrupção do CCP(Capture) "Alta"
   TMR0IP = 0;        // Prioridade de Interrupção do TIMER0 "Baixa"
   TMR1IP = 0;        // Prioridade de Interrupção do TIMER1 "Baixa"
   TMR3IP = 1;        // Prioridade de Interrupção do TIMER3 "Alta"
   TMR2IP = 0;        // Prioridade de Interrupção do TIMER2 "Baixa"
   
   

   /*------------------------Inicio Config. SPI - MC33810---------------------*/
   //Selecao do SPI - MC33810
   nSINAL_SS_SINC = nPin_HIGH;
   nSINAL_SS_33810 = nPin_LOW;

   // Calibracao do Clock - MC33810
   Spi_Write16(0b1110000000000000);
   nSINAL_SS_33810 = nPin_HIGH;
   __delay_us(20);
   nSINAL_SS_33810 = nPin_LOW; // Pulso de 32us no CS do SPI
   __delay_us(32);               // Requisito de calibracao do MC33810
   nSINAL_SS_33810 = nPin_HIGH;
   __delay_us(20);
   nSINAL_SS_33810 = nPin_LOW; // Mantem o SPI do MC33810 ativo

   // SPI Check - MC33810
   // OBS: O programa espera a resposta do MC33810 para prosseguir

  /* while (temp != 0b0000110100001010)
   {
        nLED_TEST = !nLED_TEST;
        temp = spi_write_read_16(0b0000111100000000);
        __delay_us(2);
   }*/

   nSINAL_SS_33810 = nPin_HIGH;
   __delay_us(20);
   nSINAL_SS_33810 = nPin_LOW;

   // Modo de Operacao - MC33810
   Spi_Write16(0b0001111100000000); // Setado p/ GENERAL PURPOSE GATE DRIVER MODE

   nSINAL_SS_33810 = nPin_HIGH;
   __delay_us(20);
   nSINAL_SS_33810 = nPin_LOW;

   // LSD Fault Command - MC33810
   Spi_Write16(0b0010101011111111);

   nSINAL_SS_33810 = nPin_HIGH;
   // Habilita saidas - MC33810
   //output_low(OUTEN_33810); //Habilitado pelo PIC Sincronismo
   //------------------------Fim Config. SPI - MC33810------------------------
   SPI_MASTER1();

   Enable_Interrupt(nINTERRUPT_GLOBAL);
   Enable_Interrupt(nINTERRUPT_PERIPHERAL);
   Enable_Interrupt(nINT_TIMER1);
   Enable_ExtInt(nExt_Int0);
   Enable_Interrupt(nINT_CCP1);
      
   while(1);
}
/*************************************
 *       END SW GERENCIAMENTO        *
 ************************************/

/*
 *                                 PIC18F46K22
 *                          +---------:_:---------+
 *              VPP MCLR -> : 01 VPP       PGD 40 : <> RB7 PGD
 *           Pedal1  RA0 <> : 02           PGC 39 : <> RB6 PGC 
 *            Pedal2 RA1 <> : 03           PGM 38 : <> RB5 Sensor Pressão A/C
 *           Lambda1 RA2 <> : 04               37 : <> RB4 Temp Ar
 *                   RA3 <> : 05               36 : <> RB3     
 *                   RA4 <> : 06 T0CKI         35 : <> RB2 Battery     
 *        Temp Agua  RA5 <> : 07               34 : <> RB1     
 *              MAP  RE0 <> : 08          INT0 33 : <> RB0 Rotação
 *                   RE1 <> : 09               32 : <----- VDD
 *                   RE2 <> : 10               31 : <----- VSS
 *              VDD ------> : 11               30 : <> RD7
 *              VSS ------> : 12               29 : <> RD6 Botão A/C
 *    10MHZ_CRYSTAL OSC1 -> : 13 OSC1          28 : <> RD5 Freio2
 *    10MHZ_CRYSTAL OSC2 <- : 14 OSC2          27 : <> RD4
 *                   RC0 <> : 15 T1CKI         26 : <> RC7 Embreagem
 *                   RC1 <> : 16               25 : <> RC6
 * SensorCombustível RC2 <> : 17               24 : <> RC5
 *                   RC3 <> : 18               23 : <> RC4
 *                   RD0 <> : 19               22 : <> RD3 
 *                   RD1 <> : 20               21 : <> RD2 Freio1
 *                          +---------------------+
 *                                  DIP-40
 */